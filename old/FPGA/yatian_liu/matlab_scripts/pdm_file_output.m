% Convert the input pdm signal to .mif format output.
function pdm_file_output(pdm_sig, filename)
    pdm_sig = int8(pdm_sig);
    % Here I use integer type first to avoid floating-point error.
    output_len = int32(length(pdm_sig));
    if mod(output_len, 8) == 0
        output_len = idivide(output_len, 8);
    else
        output_len = idivide(output_len, 8) + 1;
    end
    len_digits = length(int2str(output_len));
    output_len = double(output_len);

    % Output is done using 8-bit data width and big-endian.
    outfile = fopen(filename, 'w');

    fprintf(outfile, '-- PDM signal generated by MATLAB.\n\n');

    fprintf(outfile, 'DEPTH = %d;\n', output_len);
    fprintf(outfile, 'WIDTH = 8;\n');
    fprintf(outfile, 'ADDRESS_RADIX = UNS; -- unsigned decimal\n');
    fprintf(outfile, 'DATA_RADIX = HEX;\n\n');

    fprintf(outfile, 'CONTENT BEGIN\n');
    for i = 0:output_len-2 % Last address needs special treatment
        sum = 0;
        for j = 1:8
            addr = 8*i + j;
            % Notice big-endianess.
            if pdm_sig(addr) == 1
                sum = sum * 2 + 1;
            else
                sum = sum * 2;
            end
        end
        fprintf(outfile, '%*d : %02x;\n', len_digits, i, sum);
    end
    % Dealing with the last address.
    sum = 0;
    for j = 1:(length(pdm_sig) - 8*(output_len-1))
        addr = 8*(output_len-1) + j;
        if pdm_sig(addr) == 1
            sum = sum * 2 + 1;
        else
            sum = sum * 2;
        end
    end
    fprintf(outfile, '%*d : %02x;\n', len_digits, output_len-1, sum);
    fprintf(outfile, '\nEND;\n', len_digits, output_len-1, sum);

    assert(fclose(outfile) == 0);
end
